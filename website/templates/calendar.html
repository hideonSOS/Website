<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>アクアライブステーション・出演者</title>
  <!--
    これは黒背景の月間カレンダーテンプレートです。
    ● フロント単体で動作：localStorage へ保存（デモ用）
    ● バックエンド連携（任意）：/api/events を叩いて同期

    ▼ バックエンドAPIの想定（例：Django / FastAPI 等）
      GET    /api/events?month=YYYY-MM               -> [{id, date:"YYYY-MM-DD", title, time?, description?}]
      POST   /api/events                              -> 受信JSON {date, title, time?, description?} を登録して {id, ...} を返す
      DELETE /api/events/{id}                         -> そのイベントを削除

    ▼ Django の場合のCSRF
      ・Cookie 名: csrftoken を読み、fetch ヘッダに 'X-CSRFToken' を付与してください。

    ▼ 使い方
      1) ファイルをそのまま開くと、ローカル保存モード（localStorage）で動きます。
      2) 同期先APIを用意したら const API_BASE = '' を空文字のままでも
         絶対/相対で '/api/events' を叩きます（失敗したら自動でローカル保存にフォールバック）。
  -->
  <style>
    :root{
      --bg: #000;          /* 背景（黒） */
      --fg: #e5e7eb;       /* 文字色（明灰） */
      --muted: #9ca3af;    /* 補助文字 */
      --accent: #22d3ee;   /* アクセント（シアン） */
      --grid: #1f2937;     /* グリッド線 */
      --cell: #0b0b0b;     /* セル背景 */
      --cell-hover: #111827; /* セルhover */
      --other-month: #0a0a0a; /* 前後月セル */
      --sun: #f87171;      /* 日曜 */
      --sat: #60a5fa;      /* 土曜 */
    }
    html, body { height: 100%; }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", "Meiryo", sans-serif;
      line-height:1.5; -webkit-font-smoothing:antialiased;
    }
    .container{ max-width:1100px; margin:0 auto; padding:24px 16px 48px; }

    /* ヘッダー */
    .header{ display:flex; align-items:center; gap:12px; justify-content:space-between; margin-bottom:12px; }
    .left, .right{ display:flex; align-items:center; gap:8px; }
    .brand{ font-size:18px; color:var(--muted); letter-spacing:.04em; }
    .monthLabel{ font-size:28px; font-weight:700; letter-spacing:.02em; }
    .badge{ font-size:12px; padding:2px 8px; border:1px solid var(--grid); border-radius:999px; color:var(--muted); }

    button{ cursor:pointer; border:none; border-radius:12px; background:#0f172a; color:var(--fg); padding:10px 14px; font-weight:600; }
    button:hover{ background:#111827; }
    .iconbtn{ width:42px; height:42px; display:grid; place-items:center; border-radius:12px; }

    /* 曜日ヘッダ */
    .weekday{ display:grid; grid-template-columns: repeat(7, 1fr); gap:6px; margin-top:10px; }
    .weekday div{ text-align:center; padding:10px 0; font-size:12px; color:var(--muted); border-bottom:1px solid var(--grid); }
    .weekday .sun{ color:var(--sun); }
    .weekday .sat{ color:var(--sat); }

    /* カレンダー本体 */
    .grid{ display:grid; grid-template-columns: repeat(7, 1fr); gap:6px; margin-top:8px; }
    .day{
      position:relative; min-height:220px; background:var(--cell); border:1px solid var(--grid); border-radius:12px; padding:8px; overflow:hidden;
      transition: background .15s ease;
    }
    .day:hover{ background:var(--cell-hover); }
    .day.other{ background:var(--other-month); opacity:.7; }
    .num{
      position:absolute; top:8px; right:10px; font-size:12px; color:var(--muted);
    }
    .today{ outline:2px solid var(--accent); outline-offset:-2px; }

    .events{ margin-top:22px; display:flex; flex-direction:column; gap:6px; }
    .pill{ display:inline-flex; align-items:center; gap:8px; font-size:12px; background:#0d3b45; border:1px solid #134e5a; padding:6px 8px; border-radius:999px; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; }
    .pill .time{ color:#a7f3d0; font-weight:700; }

    /* フッタの説明 */
    .help{ margin-top:14px; color:var(--muted); font-size:12px; }

    /* モーダル（<dialog>） */
    dialog{ border:none; border-radius:16px; padding:0; width:min(560px, 92vw); background:#0b1220; color:var(--fg); box-shadow:0 20px 60px rgba(0,0,0,.6); }
    dialog::backdrop{ background:rgba(0,0,0,.6); }
    .modalHead{ display:flex; align-items:center; gap:10px; justify-content:space-between; padding:16px 18px; border-bottom:1px solid var(--grid); }
    .modalTitle{ font-weight:700; }
    .modalBody{ padding:18px; display:grid; gap:14px; }
    .row{ display:grid; gap:6px; }
    label{ font-size:12px; color:var(--muted); }
    input[type="text"], input[type="time"], input[type="date"], textarea{ background:#0f172a; color:var(--fg); border:1px solid var(--grid); border-radius:10px; padding:10px 12px; outline:none; color-scheme: dark; }
    textarea{ min-height:80px; resize:vertical; }
    .modalFoot{ display:flex; justify-content:space-between; align-items:center; padding:16px 18px; border-top:1px solid var(--grid); }
    .danger{ background:#3f1d1d; }
    .danger:hover{ background:#4a2323; }

    .listEmpty{ color:var(--muted); font-size:12px; }
    .eventList{ display:flex; flex-direction:column; gap:8px; }
    .eventItem{ display:flex; align-items:center; justify-content:space-between; border:1px solid var(--grid); background:#0f172a; padding:8px 10px; border-radius:10px; }
    .eventItem .meta{ display:flex; gap:8px; font-size:12px; color:var(--muted); }
    /* 3レーン（MC/解説者1/解説者2）用 */
    .lanes{ display:grid; grid-template-rows: repeat(4, 1fr); gap:6px; margin-top:24px; }
    .lane{ display:flex; flex-direction:column; gap:6px; border:1px dashed var(--grid); border-radius:10px; padding:6px; }
    .laneTitle{ font-size:11px; color:var(--muted); letter-spacing:.02em; }
    .laneBody{ display:flex; flex-direction:column; gap:6px; }
  /* 開催日色分け */
    .day.race{ background:#0b1e2e; border-color:#1e3a5f; }
    .day.race:hover{ background:#0d2540; }
    .raceTag{ position:absolute; top:8px; left:10px; font-size:11px; padding:2px 6px; border-radius:8px; background:#102846; border:1px solid #1e3a5f; color:#93c5fd; }
  /* 入力ピッカーのアイコンを明るい青に */
    input[type="date"]::-webkit-calendar-picker-indicator,
    input[type="time"]::-webkit-calendar-picker-indicator{
      filter: invert(78%) sepia(24%) saturate(1000%) hue-rotate(145deg) brightness(110%) contrast(100%);
      cursor:pointer;
    }
    input[type="checkbox"]{ accent-color: var(--accent); }
  /* メモ表示 */
    .memo{ font-size:11px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .noteIcon{ font-size:12px; opacity:.9; }
  .num {
  color: #00e5ff;  /* 例：ゴールド */
  font-weight: bold; /* 太字にする場合 */
  font-size:12px;
}
.header {
  position: sticky;
  top: 0;
  background: #000;  /* 背景を指定しないと下の要素が透ける */
  z-index: 100;      /* 前面に出す */
}
.btn-link {
    display: inline-block;
    padding: 5px 16px;
    background: #0f172a;   /* ボタン背景色 */
    color: #e5e7eb;       /* 文字色 */
    border: 1px solid #334155;
    border-radius: 10px;
    text-decoration: none; /* aタグの下線を消す */
    font-weight: bold;
    cursor: pointer;
    font-size: 12px;
  }
  .btn-link:hover {
    background: #111827; /* hover時の色 */
  }
  .monthLabel {
  font-size: 22px;
  font-weight: 700;
  letter-spacing: .02em;
}
</style>
</head>
<body>
  <div class="container">
    <div class="header" aria-label="カレンダーナビゲーション">
      <div class="left">
        <button class="iconbtn" id="prevBtn" aria-label="前の月へ">◀</button>
        <div class="monthLabel" id="monthLabel">----</div>
        <button class="iconbtn" id="nextBtn" aria-label="次の月へ">▶</button>
      </div>
      <div class="right">
        <span class="badge" id="modeBadge" title="サーバーと疎通できない場合は自動でローカル保存に切替">モード判定中…</span>
        <button id="todayBtn" aria-label="今月へ">今日へ</button>
        <a class="btn-link" href= "{% url 'website:index' %}">トップページ</a>
      </div>
    </div>

    <div class="weekday" aria-hidden="true">
      <div>月</div>
      <div>火</div>
      <div>水</div>
      <div>木</div>
      <div>金</div>
      <div class="sat">土</div>
      <div class="sun">日</div>
    </div>

    <div class="grid" id="grid" role="grid" aria-label="月間カレンダー"></div>

    <p class="help">ヒント：日付セルをクリックすると追加できます。モーダルは ESC または背景クリックで閉じます（×ボタンは非表示）。</p>
  </div>

  <!-- 追加/編集モーダル（ダイアログ） -->
  <dialog id="eventDialog">
    <form id="eventForm">
      <div class="modalHead">
        <div class="modalTitle" id="dialogTitle">予定を追加</div>
        <!-- ×ボタンは置かず、ESC/背景クリックで閉じる方針 -->
      </div>
      <div class="modalBody">
        <div class="row">
          <label for="dateInput">日付</label>
          <input type="date" id="dateInput" required />
        </div>
        <div class="row">
          <label for="roleSelect">役割</label>
          <select id="roleSelect">
            <option value="MC">MC</option>
            <option value="解説者1">解説者1</option>
            <option value="解説者2">解説者2</option>
            <option value="ゲスト">ゲスト</option>
          </select>
        </div>
        <div class="row">
          <label><input type="checkbox" id="isRaceDay"> 開催日</label>
        </div>
        <div class="row">
          <label for="raceTitleInput">開催タイトル（任意）</label>
          <input type="text" id="raceTitleInput" placeholder="例：大阪ダービー第42回摂河泉競走" />
        </div>
        <div class="row">
          <label for="titleInput">出演者</label>
          <input type="text" id="titleInput" placeholder="例：出演者名（MC・解説者・ゲスト）" />
        </div>
        <div class="row">
          <label for="descInput">メモ（任意）</label>
          <textarea id="descInput" placeholder="詳細メモ"></textarea>
        </div>
        <div class="row">
          <strong style="font-size:12px; color:var(--muted);">この日のイベント</strong>
          <div id="eventList" class="eventList"></div>
        </div>
      </div>
      <div class="modalFoot">
        
        <div>
          <button type="submit" id="saveBtn">追加</button>
          <button type="button" id="closeBtn">閉じる</button>
        </div>
      </div>
    </form>
  </dialog>

  <script>
    // =============================
    // 設定
    // =============================
    const API_BASE = '';
    const ROLE_ORDER = ['MC','解説者1','解説者2','ゲスト']; // 相対で '/api/events' を利用。失敗時は自動フォールバック（localStorage）

    // =============================
    // ユーティリティ
    // =============================
    const pad = (n) => String(n).padStart(2, '0');
    const fmtDate = (d) => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    const parseDateStr = (str) => {
      const [y,m,dd] = str.split('-').map(Number);
      return new Date(y, m-1, dd);
    };

    function getCSRFToken(){
      // Django想定：cookie "csrftoken" を返す
      const m = document.cookie.match(/(?:^|; )csrftoken=([^;]+)/);
      return m ? decodeURIComponent(m[1]) : '';
    }

    // localStorage キー
    const LS_KEY = 'calendarEvents_v1';
    const LS_RACE_KEY = 'calendarRace_v1';

    function readLocalRace(){ try{ return JSON.parse(localStorage.getItem(LS_RACE_KEY) || '[]'); }catch{ return []; } }
    function writeLocalRace(list){ localStorage.setItem(LS_RACE_KEY, JSON.stringify(list)); }

    function readLocalEvents(){
      try{ return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }catch{ return []; }
    }
    function writeLocalEvents(list){
      localStorage.setItem(LS_KEY, JSON.stringify(list));
    }

    // ID発行（ローカル用）
    function uid(){ return 'ev_' + Date.now().toString(36) + Math.random().toString(36).slice(2,8); }

    // =============================
    // API クライアント（失敗時フォールバック）
    // =============================
    let serverAvailable = false; // 起動時に判定

    async function tryServer(){
      // 適当な月で軽く GET を試みて疎通確認
      try{
        const now = new Date();
        const ym = `${now.getFullYear()}-${pad(now.getMonth()+1)}`;
        const res = await fetch(`/api/events?month=${ym}`, { method:'GET' });
        serverAvailable = res.ok; // 200系なら利用
      }catch{
        serverAvailable = false;
      }
      updateModeBadge();
    }

    function updateModeBadge(){
      const badge = document.getElementById('modeBadge');
      if(serverAvailable){
        badge.textContent = '';
        badge.style.color = '#a7f3d0';
        badge.style.borderColor = '#134e5a';
      }else{
        badge.textContent = 'スマホの方は画面を横にしてご覧ください。';
        badge.style.color = '#fde68a';
        badge.style.borderColor = '#4b5563';
      }
    }

    async function fetchEventsByMonth(year, month){
      const ym = `${year}-${pad(month)}`;
      if(serverAvailable){
        try{
          const res = await fetch(`/api/events?month=${ym}`, { method:'GET' });
          if(res.ok) return await res.json();
        }catch{ /* フォールバック */ }
      }
      // フォールバック：ローカルから月抽出
      const all = readLocalEvents();
      return all.filter(ev => (ev.date || '').startsWith(ym));
    }

    async function createEvent(payload){
      // payload: {date, title, time?, description?}
      if(serverAvailable){
        try{
          const res = await fetch(`/api/events`, {
            method:'POST',
            headers:{ 'Content-Type':'application/json', 'X-CSRFToken': getCSRFToken() },
            body: JSON.stringify(payload)
          });
          if(res.ok){ return await res.json(); } // {id, ...}
        }catch{ /* フォールバック */ }
      }
      // ローカル保存
      const list = readLocalEvents();
      const ev = { id: uid(), ...payload };
      list.push(ev); writeLocalEvents(list);
      return ev;
    }

    async function deleteEvent(id){
      if(serverAvailable){
        try{
          const res = await fetch(`/api/events/${encodeURIComponent(id)}`, {
            method:'DELETE', headers:{ 'X-CSRFToken': getCSRFToken() }
          });
          if(res.ok) return true;
        }catch{ /* フォールバック */ }
      }
      // ローカル削除
      const list = readLocalEvents();
      const idx = list.findIndex(e => e.id === id);
      if(idx !== -1){ list.splice(idx,1); writeLocalEvents(list); return true; }
      return false;
    }

    async function deleteAllOn(dateStr){
      if(serverAvailable){
        // サーバー側に一括削除APIが無い場合は個別に取得->削除を実装してください
        const d = await fetchEventsByMonth(...ymOf(dateStr));
        const targets = d.filter(e => e.date === dateStr);
        for(const t of targets){ await deleteEvent(t.id); }
        return true;
      }else{
        const list = readLocalEvents().filter(e => e.date !== dateStr);
        writeLocalEvents(list); return true;
      }
    }

    function ymOf(dateStr){
      const d = parseDateStr(dateStr);
      return [d.getFullYear(), d.getMonth()+1];
    }

    // ===== 開催日API/ローカル =====
    async function fetchRaceByMonth(year, month){
      const ym = `${year}-${pad(month)}`;
      if(serverAvailable){
        try{
          const res = await fetch(`/api/racedays?month=${ym}`, { method:'GET' });
          if(res.ok) return await res.json();
        }catch{ /* fallback */ }
      }
      const all = readLocalRace();
      return all.filter(r => (r.date||'').startsWith(ym));
    }

    async function upsertRace(payload){ // {date, title}
      if(serverAvailable){
        try{
          const res = await fetch(`/api/racedays`, {
            method:'POST', headers:{ 'Content-Type':'application/json', 'X-CSRFToken': getCSRFToken() },
            body: JSON.stringify(payload)
          });
          if(res.ok) return await res.json();
        }catch{ /* fallback */ }
      }
      const list = readLocalRace();
      const idx = list.findIndex(r => r.date === payload.date);
      if(idx !== -1) list[idx] = { ...list[idx], ...payload };
      else list.push({ id: uid(), ...payload });
      writeLocalRace(list);
      return payload;
    }

    async function clearRace(dateStr){
      if(serverAvailable){
        try{
          const res = await fetch(`/api/racedays/${encodeURIComponent(dateStr)}`, { method:'DELETE', headers:{ 'X-CSRFToken': getCSRFToken() } });
          if(res.ok) return true;
        }catch{ /* fallback */ }
      }
      const list = readLocalRace().filter(r => r.date !== dateStr);
      writeLocalRace(list);
      return true;
    }

    // =============================
    // カレンダー描画
    // =============================
    const gridEl = document.getElementById('grid');
    const monthLabel = document.getElementById('monthLabel');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const todayBtn = document.getElementById('todayBtn');

    let current = new Date(); // 現在表示している月

    function firstDayOfMonth(y, m){ return new Date(y, m-1, 1); }
    function lastDayOfMonth(y, m){ return new Date(y, m, 0); }

    function buildMonthMatrix(y, m){
      const first = firstDayOfMonth(y,m);
      const last = lastDayOfMonth(y,m);
      const startIndex = (first.getDay() + 6) % 7; // 0=月
      const daysInMonth = last.getDate();

      const cells = [];
      // 前月分
      const prevLast = lastDayOfMonth(y, m-1);
      for(let i=0;i<startIndex;i++){
        const day = prevLast.getDate() - (startIndex - 1 - i);
        const d = new Date(y, m-2, day);
        cells.push({ date:d, inMonth:false });
      }
      // 今月分
      for(let d=1; d<=daysInMonth; d++){
        cells.push({ date:new Date(y, m-1, d), inMonth:true });
      }
      // 次月分で 6行×7列=42セルに埋める
      while(cells.length < 42){
        const lastCell = cells[cells.length-1].date;
        const d = new Date(lastCell.getFullYear(), lastCell.getMonth(), lastCell.getDate()+1);
        cells.push({ date:d, inMonth: d.getMonth() === (m-1) });
      }
      return cells;
    }

    async function render(){
      const y = current.getFullYear();
      const m = current.getMonth()+1;
      monthLabel.textContent = `${y}年${m}月`;
      gridEl.innerHTML = '';

      const cells = buildMonthMatrix(y,m);
      const monthly = await fetchEventsByMonth(y,m);
      const raceMonthly = await fetchRaceByMonth(y,m);
      const raceMap = new Map(raceMonthly.map(r => [r.date, r]));
      const byDate = new Map();
      for(const e of monthly){
        if(!byDate.has(e.date)) byDate.set(e.date, []);
        byDate.get(e.date).push(e);
      }
      // Sort events by time then title
      for(const list of byDate.values()){
        list.sort((a,b)=> (ROLE_ORDER.indexOf((a.role||'MC')) - ROLE_ORDER.indexOf((b.role||'MC'))) || a.title.localeCompare(b.title));
      }

      const todayStr = fmtDate(new Date());

      for(const c of cells){
        const d = c.date;
        const cell = document.createElement('div');
        cell.className = 'day' + (c.inMonth?'':' other');
        const dateStr = fmtDate(d);
        if(dateStr === todayStr) cell.classList.add('today');

        const num = document.createElement('div');
        num.className='num';
        num.textContent = d.getDate();
        cell.appendChild(num);

        // 開催日カラー & タグ
        const rinfo = raceMap.get(dateStr);
        if(rinfo){
          cell.classList.add('race');
          cell.title = rinfo.title ? `開催: ${rinfo.title}` : '開催';
          const tag = document.createElement('div');
          tag.className = 'raceTag';
          tag.textContent = rinfo.title ? `開催: ${rinfo.title}` : '開催';
          cell.appendChild(tag);
        }

        const roles = ['MC','解説者1','解説者2','ゲスト'];
        const allEvents = (byDate.get(dateStr) || []).map(e => ({...e, role: e.role || 'MC'}));

        const lanes = document.createElement('div');
        lanes.className = 'lanes';
        for(const role of roles){
          const lane = document.createElement('div');
          lane.className = 'lane';

          const laneTitle = document.createElement('div');
          laneTitle.className = 'laneTitle';
          laneTitle.textContent = role;
          lane.appendChild(laneTitle);

          const laneBody = document.createElement('div');
          laneBody.className = 'laneBody';

          const items = allEvents.filter(e => e.role === role);
          if(items.length === 0){
            const empty = document.createElement('div');
            empty.className = 'listEmpty';
            empty.textContent = '—';
            laneBody.appendChild(empty);
          }else{
            for(const ev of items){
              const pill = document.createElement('div');
              pill.className='pill';
              pill.title = ev.description || ''; const title = document.createElement('span'); title.textContent = ev.title; pill.appendChild(title);
              if (ev.description) {
                const note = document.createElement('span');
                note.className = 'noteIcon';
                note.textContent = '📝';
                pill.appendChild(note);
                pill.title = ev.description;
              }
              laneBody.appendChild(pill);
            }
          }
          lane.appendChild(laneBody);
          lanes.appendChild(lane);
        }
        cell.appendChild(lanes);

        // クリックで追加モーダル
        cell.addEventListener('click', () => openDialogFor(dateStr));
        gridEl.appendChild(cell);
      }
    }

    prevBtn.addEventListener('click', ()=>{ current = new Date(current.getFullYear(), current.getMonth()-1, 1); render(); });
    nextBtn.addEventListener('click', ()=>{ current = new Date(current.getFullYear(), current.getMonth()+1, 1); render(); });
    todayBtn.addEventListener('click', ()=>{ const now = new Date(); current = new Date(now.getFullYear(), now.getMonth(), 1); render(); });

    // =============================
    // モーダル & フォーム
    // =============================
    const dialog = document.getElementById('eventDialog');
    const dateInput = document.getElementById('dateInput');
    const roleSelect = document.getElementById('roleSelect');
    const isRaceDay = document.getElementById('isRaceDay');
    const raceTitleInput = document.getElementById('raceTitleInput');
    const titleInput = document.getElementById('titleInput');
    const descInput = document.getElementById('descInput');
    const eventList = document.getElementById('eventList');
    
    const closeBtn = document.getElementById('closeBtn');
    const form = document.getElementById('eventForm');

    function clearForm(){
      titleInput.value = '';
      descInput.value = '';
      if(roleSelect) roleSelect.value = 'MC';
    }

    async function refreshEventList(dateStr){
      eventList.innerHTML = '';
      const [y,m] = ymOf(dateStr);
      const list = (await fetchEventsByMonth(y,m)).filter(e => e.date === dateStr);
      if(list.length === 0){
        const p = document.createElement('div'); p.className='listEmpty'; p.textContent = 'この日の予定はまだありません';
        eventList.appendChild(p);
        return;
      }
      for(const ev of list){
        const row = document.createElement('div'); row.className='eventItem';
        const left = document.createElement('div'); left.style.display='flex'; left.style.flexDirection='column';
        const title = document.createElement('div'); title.textContent = `[${ev.role || 'MC'}] ${ev.title}`;
        const meta = document.createElement('div');
        meta.className='meta';
        meta.innerHTML = `${ev.description ? '<span>📝メモあり</span>' : ''}`;
        left.appendChild(title); left.appendChild(meta);
        if (ev.description){
          const memo = document.createElement('div');
          memo.className = 'memo';
          memo.textContent = ev.description;
          left.appendChild(memo);
        }

        const del = document.createElement('button'); del.className='danger'; del.textContent='削除';
        del.addEventListener('click', async (e)=>{
          e.preventDefault();
          await deleteEvent(ev.id);
          await refreshEventList(dateStr);
      setRaceFields(dateStr);
          await render();
        });
        row.appendChild(left); row.appendChild(del);
        eventList.appendChild(row);
      }
    }

    async function readRaceForDate(dateStr){
      const [y,m] = ymOf(dateStr);
      const list = await fetchRaceByMonth(y,m);
      return list.find(r => r.date === dateStr) || null;
    }
    async function setRaceFields(dateStr){
      if(!isRaceDay || !raceTitleInput) return;
      const r = await readRaceForDate(dateStr);
      isRaceDay.checked = !!r;
      raceTitleInput.value = r && r.title ? r.title : '';
    }

    function openDialogFor(dateStr){
      dateInput.value = dateStr;
      clearForm();
      dialog.showModal();
      refreshEventList(dateStr);
    }

    // 背景クリックで閉じる
    dialog.addEventListener('click', (e)=>{
      const rect = dialog.getBoundingClientRect();
      const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
      if(!inside) dialog.close();
    });
    // 明示ボタンで閉じる
    closeBtn.addEventListener('click', ()=> dialog.close());

    // この日の予定を全削除
    

    // 追加
    form.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const payload = {
        date: dateInput.value,
        title: titleInput.value.trim(),
        description: descInput.value.trim() || null,
        role: roleSelect.value
      };
      
      const isRace = isRaceDay && isRaceDay.checked;
      const rtitle = raceTitleInput ? raceTitleInput.value.trim() : '';
      if(isRace){ await upsertRace({ date: payload.date, title: rtitle || null }); }
      else { await clearRace(payload.date); }
      if(payload.title){ await createEvent(payload); }
      await refreshEventList(payload.date);
      await render();
      clearForm();
    });

    // 初期化
    (async function init(){
      await tryServer();
      await render();
    })();
    roleSelect.addEventListener("click", (e) => {
  e.stopPropagation();
});

  </script>
</body>
</html>
