{% load static %}
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chart.js + Vue (å›ºå®šè»¸å¯¾å¿œ)</title>
    <!-- Vue3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
      body {
        font-family: "Arial", sans-serif;
        background: #000000; /* å…¨ä½“ã‚’é»’ */
        color: #e0e0e0; /* æ–‡å­—ã¯è–„ã„ã‚°ãƒ¬ãƒ¼ */
        min-height: 100vh;
        padding: 15px;
        margin: 0;
      }
      .container {
        display: flex;
        flex-direction: row;
        gap: 15px;
        max-width: 1400px;
        margin: auto;
        height: calc(100vh - 30px);
      }
      .left-panel,
      .right-panel {
        background: #fff;
        border-radius: 15px;
        padding: 15px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);

        overflow-y: auto;
      }
      .left-panel {
        flex: 0.35; /* å·¦ã¯ç‹­ã‚ */
        min-width: 200px;
        background: #1c1c1c; /* ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼ */
      }
      .right-panel {
        display: flex;
        flex-direction: column;
        min-height: 400px;
        flex: 1.65; /* å³ã¯åºƒã‚ */
        background: #1c1c1c; /* ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼ */
      }
      .chart-wrapper {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      .chart-scroll-area {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        position: relative;
      }
      .chart-container {
        position: relative;
        min-height: 1200px; /* 60é …ç›®åˆ†ã®é«˜ã•ã‚’ç¢ºä¿ */
      }
      #myChart {
        height: 1200px !important;
      }
      .chart-fixed-axis {
        height: 60px;
        border-top: 1px solid #444; /* è–„ã„ã‚°ãƒ¬ãƒ¼ã®ä»•åˆ‡ã‚Šç·š */
        margin-top: 10px;
        position: relative;
      }
      #axisChart {
        height: 60px !important;
        width: 100% !important;
      }
      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        margin-right: 5px;
      }
      button:hover {
        opacity: 0.9;
      }
      label {
        color: #f0f0f0; /* æ˜ã‚‹ã‚ã®ã‚°ãƒ¬ãƒ¼ */
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    {% verbatim %}
    <div id="app" class="container">
      <!-- å·¦ãƒ‘ãƒãƒ« -->
      <div class="left-panel">
        <h2>ğŸ“Š å…¥åŠ›</h2>
        <div>
          <label>ãƒœãƒ¼ãƒ€ãƒ¼:</label>
          <input
            type="number"
            v-model.number="borderValue"
            min="0"
            max="13"
            step="0.01"
          />
        </div>
        <div v-for="(add, i) in adds" :key="i" style="margin-top: 10px">
          <label>{{ i+1 }} å·è‰‡ãƒ»ç€é †ç‚¹ : </label>
          <select v-model.number="adds[i].value">
            <option v-for="n in 12" :key="n" :value="n">{{ n }}</option>
          </select>
          <br />

           <label>å¯¾è±¡é¸æ‰‹ : </label>
          <select v-model="adds[i].target">
            <option value="">æœªé¸æŠ</option>
           <option v-for="name in nameOptions" :key="name" :value="name">
              {{ name }}
            </option>
          </select>

        </div>
      </div>

      <!-- å³ãƒ‘ãƒãƒ« -->
      <div class="right-panel">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
          "
        >
          <div>
            <h2>ğŸ“ˆ å¾—ç‚¹ç‡ä¸€è¦§è¡¨</h2>
            <p style="font-size: 12px; color: #fff">{{ currentTime }}</p>
          </div>
          <div>
            <!-- <button @click="updateData">æ›´æ–°</button> -->
            <button @click="toggleSort">
              {{ sortOrder ? "å…ƒã«æˆ»ã™ â†º" : "é™é † â–¼" }}
            </button>
          </div>
        </div>

        <div class="chart-wrapper">
          <!-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é ˜åŸŸ -->
          <div class="chart-scroll-area">
            <div class="chart-container">
              <canvas id="myChart"></canvas>
            </div>
          </div>
          <!-- å›ºå®šè»¸ -->
          <div class="chart-fixed-axis">
            <canvas id="axisChart"></canvas>
          </div>
        </div>
      </div>
    </div>
    {% endverbatim %} 


    {{ df_data|json_script:'data-json' }}
    <script>

      const data = JSON.parse(document.getElementById("data-json").textContent);
    
      const { createApp, ref, reactive, onMounted, watch, computed } = Vue;
const labels = ref([...data['name']]);   // åå‰é…åˆ—ï¼ˆYè»¸ãƒ©ãƒ™ãƒ«ã¯é¸æ‰‹åï¼‰
const points = ref([...data['point']]);  // å¾—ç‚¹é…åˆ—ï¼ˆæ•°å€¤ï¼‰
const counts = ref([...data['count']]);
// å…ƒã®é †åºã‚’ â€œç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿â€ ã§ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼ˆåå‰ã‚‚å¾—ç‚¹ã‚‚ä¿æŒï¼‰
const originalLabels = ref([...labels.value]);
const originalPoints = ref([...points.value]);
const originalCounts = ref([...counts.value]);

      createApp({
        setup() {
          /** -------------------------
           * ãƒ‡ãƒ¼ã‚¿å®šç¾©ï¼ˆã¾ã¨ã‚ã¦å®£è¨€ï¼‰
           * ------------------------- */
          const borderValue = ref(13); // ãƒœãƒ¼ãƒ€ãƒ¼å€¤
          const sortOrder = ref(null); // ã‚½ãƒ¼ãƒˆçŠ¶æ…‹
          const currentTime = ref(""); // ç¾åœ¨æ™‚åˆ»è¡¨ç¤º
          // å·¦ãƒ‘ãƒãƒ«ï¼šè¿½åŠ ãƒ‡ãƒ¼ã‚¿ï¼ˆtargets ã¯é¸æ‰‹åã®é…åˆ—ã«ï¼‰
          const adds = reactive(
            Array.from({ length: 6 }, () => ({ value: 0, target: "" }))
          );

          // å·¦ãƒ‘ãƒãƒ«ç”¨ï¼šé¸æ‰‹åã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³å€™è£œï¼ˆå³ã® labels ã¯ãã®ã¾ã¾ï¼‰
          const nameOptions = computed(() => labels.value);
const addedMap = computed(() => {
            const m = Object.create(null);
            labels.value.forEach(n => { m[n] = 0; });
            adds.forEach(a => {
              if (a.target && typeof a.value === "number") {
                m[a.target] = (m[a.target] || 0) + a.value;
              }
            });
            return m;
          });
          // è¿½åŠ å›æ•°ï¼šé¸æ‰‹ã”ã¨ã®ä»¶æ•°ï¼ˆé¸æŠãŒã‚ã‚Œã°1ã‚«ã‚¦ãƒ³ãƒˆï¼å€¤ãŒ0ã§ã‚‚å‡ºèµ°ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼‰
          const addedCountMap = computed(() => {
           const m = Object.create(null);
            labels.value.forEach(n => { m[n] = 0; });
            adds.forEach(a => {
              if (a.target) m[a.target] = (m[a.target] || 0) + 1;
            });
            return m;
          });
          // ç¾åœ¨ã®å¹³å‡ï¼ˆpoint / countï¼‰
          const currentAvg = computed(() =>
            labels.value.map((_, idx) => {
              const p = Number(points.value[idx] ?? 0);
              const c = Number(counts.value[idx] ?? 0);
              return c ? p / c : 0;
            })
          );
          // è¿½åŠ é©ç”¨å¾Œã®å¹³å‡ = (point + è¿½åŠ åˆè¨ˆ) / (count + è¿½åŠ å›æ•°)
          const newAvg = computed(() =>
            labels.value.map((name, idx) => {
              const p  = Number(points.value[idx] ?? 0);
              const c  = Number(counts.value[idx] ?? 0);
              const ap = Number(addedMap.value[name] ?? 0);
              const ac = Number(addedCountMap.value[name] ?? 0);
              const denom = c + ac;
              return denom ? (p + ap) / denom : 0;
            })
          );
          // ã‚¹ã‚¿ãƒƒã‚¯è¡¨ç¤ºç”¨ã®å·®åˆ†ï¼ˆæ–°å¹³å‡ - ç¾å¹³å‡ï¼‰
          const deltaAvg = computed(() =>
            newAvg.value.map((v, i) => v - currentAvg.value[i])
          );
 // å¹³å‡ = point / count ã‚’ãƒªã‚¹ãƒˆã§ç”¨æ„ï¼ˆåˆ†æ¯0ã¯ 0 ã¨ã™ã‚‹ï¼‰
          const averages = computed(() =>
            labels.value.map((_, idx) => {
              const p = Number(points.value[idx] ?? 0);
              const c = Number(counts.value[idx] ?? 0);
              return c ? p / c : 0;
            })
          );


          // Chart.js ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¿æŒç”¨
          let chartInstance = null;
          let axisInstance = null;

          /** -------------------------
           * è£œåŠ©é–¢æ•°
           * ------------------------- */
          function getBorderColors() {
            return labels.map((label) => {
              const v = originalData[label];
              return v > borderValue.value
                ? "rgba(255,152,0,0.8)"
                : "rgba(102,126,234,0.8)";
            });
          }

          function parseTargets(str) {
            if (!str) return [];
            const items = [];
            str.split(",").forEach((part) => {
              if (part.includes("-")) {
                const [s, e] = part.split("-").map(Number);
                for (let i = s; i <= e; i++) items.push(`é …ç›® ${i}`);
              } else {
                const n = Number(part);
                if (n >= 1 && n <= 60) items.push(`é …ç›® ${n}`);
              }
            });
            return items;
          }

          function getDataset() {
            const datasets = [
              {
                label: "å…ƒã®å€¤",
                data: labels.map((l) => originalData[l]),
                backgroundColor: getBorderColors(),
                borderColor: getBorderColors().map((c) =>
                  c.replace("0.8", "1")
                ),
                borderWidth: 2,
              },
            ];
            adds.forEach((add, i) => {
              const targets = parseTargets(add.targets);
              const map = labels.map((l) =>
                targets.includes(l) ? add.value : 0
              );
              datasets.push({
                label: `è¿½åŠ ${i + 1}`,
                data: map,
                backgroundColor: "rgba(200,200,200,0.4)",
              });
            });
            return datasets;
          }

          /** -------------------------
           * Chartæç”»å‡¦ç†
           * ------------------------- */
         

          function renderChart() {
            const ctx = document.getElementById("myChart");
            if (chartInstance) chartInstance.destroy();
            chartInstance = new Chart(ctx, {
              type: "bar",
            data: { 
                labels: labels.value, 
                 datasets: (() => {
                  // â¶ ä¸Šç«¯ã‚’å¸¸ã«ã€Œæ–°ã—ã„å¹³å‡ã€ã«ã™ã‚‹ï¼ˆè² ã®å·®åˆ†ã¯æã‹ãªã„ï¼‰
                  const basePart = labels.value.map((_, i) =>
                    Math.min(currentAvg.value[i], newAvg.value[i])
                  );
                  const incPart = labels.value.map((_, i) =>
                    Math.max(newAvg.value[i] - currentAvg.value[i], 0)
                  );
                  return [
                    {
                      label: "å¹³å‡ï¼ˆåŸºæº–ï¼‰",
                      data: basePart,
                      backgroundColor: "rgba(102,126,234,0.8)",  // é’
                      borderColor: "rgba(102,126,234,1)",
                      borderWidth: 2,
                    },
                    {
                     label: "å¹³å‡ï¼ˆå¢—åŠ åˆ†ï¼‰",
                      data: incPart,
                      backgroundColor: "rgba(255,152,0,0.8)",    // ã‚ªãƒ¬ãƒ³ã‚¸
                      borderColor: "rgba(255,152,0,1)",
                      borderWidth: 2,
                    },
                  ];
                })()




               },  




              options: {
                indexAxis: "y",
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: {
                    display: true,
                    position: "top",
                    labels: { color: "#fff" }   // â˜…å‡¡ä¾‹ãƒ©ãƒ™ãƒ«ã‚’ç™½ã«
                  }
                },
                scales: {
                  x: { stacked: true, display: false, max: 13 },
                  y: {
                    stacked: true,
                    ticks: { autoSkip: false, font: { size: 14 }, color: "#fff"},
                  },
                },
              },
            });

            const axisCtx = document.getElementById("axisChart");
            if (axisInstance) axisInstance.destroy();
            axisInstance = new Chart(axisCtx, {
              type: "bar",
              data: {
                labels: labels.value,
                datasets: [
                  {
                    data: labels.value.map(() => 0),
                    backgroundColor: "rgba(0,0,0,0)",
                  },
                ],
              },
              options: {
                indexAxis: "y",
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  tooltip: { enabled: false },
                },
                scales: {
                  x: { beginAtZero: true, max: 13, ticks: { stepSize: 1,color: "#fff" } },
                  y: { ticks: { color: "rgba(0,0,0,0)" } },
                },
              },
            });
          }

          /** -------------------------
           * UIæ“ä½œé–¢æ•°
           * ------------------------- */
          function updateData() {
            labels.forEach((label) => {
              originalData[label] = Math.floor(Math.random() * 13);
            });
            sortOrder.value = null;
            renderChart();
            updateTime();
          }
          function toggleSort() {
            if (sortOrder.value) {
              // å…ƒã«æˆ»ã™ï¼šåˆæœŸã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‹ã‚‰å®Œå…¨å¾©å…ƒï¼ˆå…ƒã®ä¸¦ã³ï¼‹å…ƒã®ç‚¹æ•°ï¼‰
              sortOrder.value = null;
              labels.value = [...originalLabels.value];
              points.value = [...originalPoints.value];
              counts.value = [...originalCounts.value];
            } else {
              // æ–°å¹³å‡ï¼ˆ(point+è¿½åŠ )/(count+è¿½åŠ å›æ•°)ï¼‰ã§é™é †ã‚½ãƒ¼ãƒˆ
              sortOrder.value = "desc";
              // åå‰â†’å…ƒç‚¹ ã®ãƒãƒƒãƒ—ã‚’ä½œæˆ
              const baseByName = Object.create(null);
              labels.value.forEach((name, idx) => { baseByName[name] = points.value[idx]; });
              
              const countByName = Object.create(null);
              labels.value.forEach((name, idx) => { countByName[name] = counts.value[idx]; });
              const addedSumByName   = Object.create(null);
              const addedTimesByName = Object.create(null);
              labels.value.forEach(name => {
                addedSumByName[name]   = addedMap.value[name] ?? 0;
                addedTimesByName[name] = addedCountMap.value[name] ?? 0;
              });
              const avgOf = (name) => {
                const p  = baseByName[name]  || 0;
                const c  = countByName[name] || 0;
                const ap = addedSumByName[name]   || 0;
                const ac = addedTimesByName[name] || 0;
                const denom = c + ac;
                return denom ? (p + ap) / denom : 0;
              };
              const sortedNames = [...labels.value].sort((a, b) => avgOf(b) - avgOf(a));



              // ä¸¦ã³ã‚’é©ç”¨ï¼šlabels ã¯åå‰é †ã€points ã¯å¯¾å¿œã™ã‚‹å…ƒç‚¹ã‚’å†é…ç½®
              labels.value = sortedNames;
              points.value = sortedNames.map(n => baseByName[n]);
              counts.value = sortedNames.map(n => countByName[n]);
            }
            renderChart();
          }
          


          function updateTime() {
            const now = new Date();
            currentTime.value = `${
              now.getMonth() + 1
            }æœˆ${now.getDate()}æ—¥ ${now.getHours()}æ™‚${now.getMinutes()}åˆ† ç¾åœ¨`;
          }

          /** -------------------------
           * ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«
           * ------------------------- */
          onMounted(() => {
            renderChart();
            updateTime();
            setInterval(updateTime, 60000);
          });

          watch([borderValue, adds], renderChart, { deep: true });

          return {
            borderValue,
            adds,
            currentTime,
            updateData,
            toggleSort,
            sortOrder,
            nameOptions,
            averages
            
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
